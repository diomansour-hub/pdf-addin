<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Beheerder met OCR</title>

    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Office.js: The Microsoft Office JavaScript API library -->
    <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js" type="text/javascript"></script>

    <!-- PDF.js: Library to render PDF documents in the browser -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    
    <!-- *** NIEUW: Tesseract.js voor OCR (Optical Character Recognition) *** -->
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>

    <style>
        /* A simple loader and some specific styles for the add-in */
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .approve-mode-active { box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.5); background-color: #15803d; }
        .reject-mode-active { box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.5); background-color: #b91c1c; }
        .textsnip-mode-active { box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5); background-color: #1d4ed8; }

        .page-container { position: relative; margin: 0.5rem auto; box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
        .annotation-canvas { position: absolute; top: 0; left: 0; }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div id="app" class="p-4 flex flex-col h-screen">
        <header class="mb-4">
            <h1 class="text-xl font-bold text-gray-800">PDF Beheerder</h1>
            <p class="text-sm text-gray-600">Voeg PDF's toe, maak ze doorzoekbaar (OCR), en koppel annotaties.</p>
        </header>

        <div class="controls bg-white p-3 rounded-lg shadow-sm border border-gray-200 mb-4 space-y-3">
            <div class="flex items-center space-x-2">
                <label for="pdf-file-input" class="cursor-pointer bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition-colors text-sm font-medium">
                    Voeg PDF toe
                </label>
                <input type="file" id="pdf-file-input" accept=".pdf" class="hidden">
                <p id="selected-file-name" class="text-xs text-gray-500 truncate flex-grow">Geen nieuw bestand geselecteerd.</p>
            </div>
            <div class="flex items-center space-x-2">
                <select id="pdf-switcher" class="flex-grow p-2 border border-gray-300 rounded-md text-sm">
                    <option>Geen documenten geladen</option>
                </select>
                <button id="export-pdf-button" disabled class="bg-gray-300 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">Exporteer</button>
                <button id="delete-pdf-button" disabled class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">Verwijder</button>
            </div>
            <div class="flex items-center space-x-2">
                 <button id="approve-button" disabled class="flex-1 bg-gray-300 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">Goedkeuren</button>
                 <button id="reject-button" disabled class="flex-1 bg-gray-300 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">Afkeuren</button>
                 <button id="textsnip-button" disabled class="flex-1 bg-gray-300 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">Textsnip</button>
            </div>
            <div class="text-xs text-gray-600 bg-gray-100 p-2 rounded-md">
                Geselecteerde cel: <span id="active-cell-address" class="font-mono font-bold">Geen</span>
            </div>
        </div>

        <main class="flex-grow bg-white rounded-lg shadow-sm border border-gray-200 overflow-y-auto p-2">
            <div id="status-message" class="h-full flex flex-col items-center justify-center text-gray-500">
                <div id="loader" class="loader hidden mb-2"></div>
                <span id="status-text">Voeg een PDF toe om te beginnen.</span>
            </div>
            <div id="pdf-viewer" class="space-y-2"></div>
        </main>
    </div>

    <div id="manual-text-modal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full flex items-center justify-center">
        <div class="relative mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
            <div class="mt-3 text-center">
                <h3 class="text-lg leading-6 font-medium text-gray-900">Handmatige Invoer</h3>
                <div class="mt-2 px-7 py-3">
                    <p class="text-sm text-gray-500 mb-2">Geen tekst gevonden. Voer de tekst handmatig in.</p>
                    <textarea id="manual-text-input" class="w-full h-24 p-2 border rounded-md"></textarea>
                </div>
                <div class="items-center px-4 py-3">
                    <button id="manual-save-button" class="px-4 py-2 bg-blue-500 text-white text-base font-medium rounded-md w-auto shadow-sm hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-300">
                        Opslaan
                    </button>
                    <button id="manual-cancel-button" class="ml-2 px-4 py-2 bg-gray-200 text-gray-800 text-base font-medium rounded-md w-auto shadow-sm hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-300">
                        Annuleren
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script type="text/javascript">
        // Set the worker source for PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        Office.onReady((info) => {
            if (info.host === Office.HostType.Excel) {
                // --- UI Elements ---
                const approveButton = document.getElementById('approve-button');
                const rejectButton = document.getElementById('reject-button');
                const textsnipButton = document.getElementById('textsnip-button');
                const activeCellAddressLabel = document.getElementById('active-cell-address');
                const fileInput = document.getElementById('pdf-file-input');
                const exportButton = document.getElementById('export-pdf-button');
                const deleteButton = document.getElementById('delete-pdf-button');
                const pdfSwitcher = document.getElementById('pdf-switcher');
                const selectedFileNameLabel = document.getElementById('selected-file-name');
                const pdfViewer = document.getElementById('pdf-viewer');
                const statusMessage = document.getElementById('status-message');
                const statusText = document.getElementById('status-text');
                const loader = document.getElementById('loader');
                const manualTextModal = document.getElementById('manual-text-modal');
                const manualTextInput = document.getElementById('manual-text-input');
                const manualSaveButton = document.getElementById('manual-save-button');
                const manualCancelButton = document.getElementById('manual-cancel-button');

                // --- Application State ---
                let pdfCollection = [];
                let activePdfId = null;
                let activeCellAddress = null;
                let currentDrawMode = null; 
                let isDrawing = false;
                let startCoords = { x: 0, y: 0 };
                let currentPdfDocument = null;
                let manualInputState = null;

                // --- Event Listeners ---
                fileInput.addEventListener('change', handleFileWithOcr); // *** AANGEPAST ***
                pdfSwitcher.addEventListener('change', switchActivePdf);
                exportButton.addEventListener('click', exportPdfFromSettings);
                approveButton.addEventListener('click', () => setDrawMode('approved'));
                rejectButton.addEventListener('click', () => setDrawMode('rejected'));
                textsnipButton.addEventListener('click', () => setDrawMode('textsnip'));
                deleteButton.addEventListener('click', deleteCurrentPdf);
                Office.context.document.addHandlerAsync(Office.EventType.DocumentSelectionChanged, onSelectionChange);
                manualSaveButton.addEventListener('click', handleManualSave);
                manualCancelButton.addEventListener('click', handleManualCancel);

                // --- CORE FUNCTIONS ---
                
                function initializeApp() {
                    const collectionJson = Office.context.document.settings.get('pdfCollection');
                    pdfCollection = collectionJson ? JSON.parse(collectionJson) : [];
                    updatePdfSwitcher();
                    onSelectionChange(); 
                    if (pdfCollection.length > 0 && !activePdfId) {
                        loadPdf(pdfCollection[0].id);
                    } else if (pdfCollection.length === 0) {
                        updateStatus('Voeg een PDF toe om te beginnen.', 'info');
                        setButtonsState(false);
                    }
                }
                
                async function onSelectionChange() {
                    try {
                        await Excel.run(async (context) => {
                            const range = context.workbook.getSelectedRange();
                            range.load("address");
                            await context.sync();
                            const previousCellAddress = activeCellAddress;
                            activeCellAddress = range.address;
                            activeCellAddressLabel.textContent = activeCellAddress || 'Geen';
                            
                            const annotationLocation = findAnnotationByCellAddress(activeCellAddress);
                            if (annotationLocation) {
                                if (annotationLocation.pdfId !== activePdfId) {
                                    await loadPdf(annotationLocation.pdfId);
                                    scrollToPage(annotationLocation.pageNum);
                                } else {
                                    redrawAllAnnotations();
                                    scrollToPage(annotationLocation.pageNum);
                                }
                            } else {
                                redrawAllAnnotations();
                            }
                        });
                    } catch (error) { console.error("Error getting selection: " + error); }
                }

                // --- OCR & PDF HANDLING ---

                // *** BIJGEWERKT: Gebruikt nu de correcte "raw" GitHub URL's ***
                async function handleFileWithOcr(event) {
                    if (event.target.files.length === 0) return;
                    const selectedFile = event.target.files[0];
                    selectedFileNameLabel.textContent = `Nieuw: ${selectedFile.name}`;

                    showLoader(`PDF analyseren...`);

                    let numPages = 0;
                    try {
                        const fileData = await selectedFile.arrayBuffer();
                        const pdfDoc = await pdfjsLib.getDocument({ data: fileData }).promise;
                        numPages = pdfDoc.numPages;
                        updateStatus(`Klaarmaken voor OCR (${numPages} pagina's)...`, 'info', true);
                    } catch (e) {
                        console.error("Kon paginanummer niet lezen, OCR wordt toch gestart.", e);
                        updateStatus('Klaarmaken voor OCR...', 'info', true);
                    }

                    let worker;
                    try {
                        updateStatus('Tesseract worker aanmaken...', 'info', true);
                        
                        // --- START AANPASSING VOOR GITHUB URL'S ---
                        // Dit zijn de correcte, directe links naar de bestanden op GitHub.
                        const workerPath = 'https://raw.githubusercontent.com/diomansour-hub/pdf-addin/main/worker.min.js';
                        const langPath = 'https://raw.githubusercontent.com/diomansour-hub/pdf-addin/main/'; // Pad naar de map

                        const workerPromise = Tesseract.createWorker(workerPath, 1, { // Het tweede argument '1' is voor de taal
                            langPath: langPath,
                            gzip: false, // Belangrijk voor GitHub raw links
                            logger: m => {
                                const pageContext = numPages > 0 ? ` (totaal ${numPages} pag.)` : '';
                                if (m.status === 'recognizing text') {
                                    const progress = (m.progress * 100).toFixed(0);
                                    statusText.textContent = `Tekstherkenning${pageContext}: ${progress}%`;
                                } else {
                                    let statusNL = m.status;
                                    switch(m.status) {
                                        case 'loading language model': statusNL = 'taalmodel laden'; break;
                                        case 'initializing': statusNL = 'initialiseren'; break;
                                        case 'initialized': statusNL = 'geïnitialiseerd'; break;
                                        case 'loading': statusNL = 'laden'; break;
                                        case 'loaded': statusNL = 'geladen'; break;
                                    }
                                    statusText.textContent = `Bezig met ${statusNL}...`;
                                }
                            }
                        });
                        // --- EINDE AANPASSING ---


                        const timeoutPromise = new Promise((_, reject) => {
                            setTimeout(() => {
                                reject(new Error("Het aanmaken van de OCR-worker duurde te lang (10min timeout)."));
                            }, 600000); // 10 minuten
                        });

                        worker = await Promise.race([workerPromise, timeoutPromise]);
                        
                        updateStatus('Taalmodel laden (nld)...', 'info', true);
                        await worker.loadLanguage('nld');

                        updateStatus('Worker initialiseren...', 'info', true);
                        await worker.initialize('nld');

                        await worker.setParameters({ tesedit_create_pdf: '1' });
                        
                        updateStatus('Tekstherkenning starten...', 'info', true);
                        const { data } = await worker.recognize(selectedFile);
                        
                        updateStatus('Verwerkte PDF opslaan...', 'info', true);
                        
                        const pdfBlob = new Blob([data.pdf], { type: 'application/pdf' });
                        const searchablePdfArrayBuffer = await pdfBlob.arrayBuffer();

                        await addPdfToCollectionAndSave(searchablePdfArrayBuffer, selectedFile.name);

                    } catch (error) {
                        console.error("OCR process failed:", error);
                        // Geef een meer gedetailleerde foutmelding aan de gebruiker
                        let userMessage = `Fout bij OCR: ${error.message || 'Onbekende fout'}.`;
                        if (error.message.includes("timeout")) {
                           userMessage += " Dit wordt meestal veroorzaakt door een netwerkprobleem of een firewall. Controleer de internetverbinding of neem contact op met IT.";
                        } else {
                           userMessage += " Controleer of 'worker.min.js' en 'nld.traineddata.gz' in dezelfde map staan als de add-in en bereikbaar zijn.";
                        }
                        updateStatus(userMessage, 'error');
                    } finally {
                        if (worker) {
                            await worker.terminate();
                        }
                        fileInput.value = '';
                        selectedFileNameLabel.textContent = 'Geen nieuw bestand geselecteerd.';
                    }
                }

                // *** NIEUW: Hulpfunctie om PDF op te slaan na verwerking ***
                async function addPdfToCollectionAndSave(pdfArrayBuffer, fileName) {
                    const newPdf = {
                        id: crypto.randomUUID(),
                        name: fileName,
                        data: arrayBufferToBase64(pdfArrayBuffer),
                        annotations: {}
                    };
                    pdfCollection.push(newPdf);
                    saveCollectionToSettings(() => {
                        updateStatus(`'${fileName}' succesvol verwerkt en toegevoegd.`, 'success');
                        updatePdfSwitcher();
                        loadPdf(newPdf.id);
                    });
                }
                
                async function loadPdf(pdfId) {
                    activePdfId = pdfId;
                    const pdfObject = pdfCollection.find(p => p.id === pdfId);
                    if (!pdfObject) {
                        initializeApp();
                        return;
                    }
                    showLoader(`'${pdfObject.name}' laden...`);
                    updatePdfSwitcher();
                    const pdfData = base64ToUint8Array(pdfObject.data);
                    await renderPdf(pdfData, pdfObject.annotations);
                    setButtonsState(true);
                    setDrawMode(null);
                }

                // --- ANNOTATION & RENDERING FUNCTIONS ---
                
                function handleMouseDown(e, pageNum) {
                     // Prevent drawing if clicking on an existing annotation
                    const pdfObject = pdfCollection.find(p => p.id === activePdfId);
                    if (pdfObject?.annotations?.[pageNum]) {
                        const rect = e.target.getBoundingClientRect();
                        const clickX = e.clientX - rect.left;
                        const clickY = e.clientY - rect.top;
                        const clickedAnnotation = [...pdfObject.annotations[pageNum]].reverse().find(anno => 
                            clickX >= anno.x && clickX <= anno.x + anno.w && 
                            clickY >= anno.y && clickY <= anno.y + anno.h
                        );
                        if (clickedAnnotation) {
                            isDrawing = false;
                            return; // Stop execution to prevent drawing a new box
                        }
                    }

                    if (!currentDrawMode) return;
                    isDrawing = true;
                    const canvasRect = e.target.getBoundingClientRect();
                    startCoords.x = e.clientX - canvasRect.left;
                    startCoords.y = e.clientY - canvasRect.top;
                }

                function handleMouseMove(e, pageNum) {
                    if (!isDrawing || !currentDrawMode) return;
                    const pdfObject = pdfCollection.find(p => p.id === activePdfId);
                    if (!pdfObject) return;
                    const canvas = document.querySelectorAll('.annotation-canvas')[pageNum - 1];
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Create a temporary copy for live preview
                    const tempAnnotations = JSON.parse(JSON.stringify(pdfObject.annotations));
                    if(!tempAnnotations[pageNum]) tempAnnotations[pageNum] = [];
                    
                    const tempRect = {
                        x: startCoords.x,
                        y: startCoords.y,
                        w: mouseX - startCoords.x,
                        h: mouseY - startCoords.y,
                        cellAddress: activeCellAddress,
                        type: currentDrawMode
                    };
                     // To draw from any corner, we need to normalize the rect for preview
                    const previewRect = {
                        x: tempRect.w < 0 ? tempRect.x + tempRect.w : tempRect.x,
                        y: tempRect.h < 0 ? tempRect.y + tempRect.h : tempRect.y,
                        w: Math.abs(tempRect.w),
                        h: Math.abs(tempRect.h),
                        cellAddress: tempRect.cellAddress,
                        type: tempRect.type
                    };

                    // Draw all existing annotations plus the new one
                    redrawAllAnnotations(); // Redraw base annotations first
                    const ctx = canvas.getContext('2d');
                    drawSingleAnnotation(ctx, previewRect);
                }

                async function handleMouseUp(e, pageNum) {
                    if (!isDrawing || !currentDrawMode || !activePdfId || !activeCellAddress) return;
                    isDrawing = false;
                    
                    const canvas = document.querySelectorAll('.annotation-canvas')[pageNum - 1];
                    const rect = canvas.getBoundingClientRect();
                    const endX = e.clientX - rect.left;
                    const endY = e.clientY - rect.top;

                    const width = endX - startCoords.x;
                    const height = endY - startCoords.y;

                    if (Math.abs(width) < 5 && Math.abs(height) < 5) {
                        redrawAllAnnotations(); 
                        return;
                    }

                    const userRect = { x: startCoords.x, y: startCoords.y, w: width, h: height };

                    if (currentDrawMode === 'textsnip') {
                        const extractedText = await extractTextFromArea(pageNum, userRect);
                        if (!extractedText || extractedText.trim() === '') {
                            showManualTextInputModal(activeCellAddress, userRect, pageNum);
                            return; // Modal will handle saving
                        }
                        await formatLinkedCell(activeCellAddress, 'textsnip', extractedText);
                    } else {
                        await formatLinkedCell(activeCellAddress, currentDrawMode);
                    }

                    saveAnnotation(pageNum, userRect, currentDrawMode);
                }

                function saveAnnotation(pageNum, userRect, type) {
                    const pdfObject = pdfCollection.find(p => p.id === activePdfId);
                    if (!pdfObject) return;

                    // Normalize the rectangle for consistent storage and rendering
                    const normalizedRect = {
                        x: userRect.w < 0 ? userRect.x + userRect.w : userRect.x,
                        y: userRect.h < 0 ? userRect.y + userRect.h : userRect.y,
                        w: Math.abs(userRect.w),
                        h: Math.abs(userRect.h)
                    };

                    if (!pdfObject.annotations[pageNum]) {
                        pdfObject.annotations[pageNum] = [];
                    }

                    pdfObject.annotations[pageNum].push({ 
                        ...normalizedRect,
                        cellAddress: activeCellAddress,
                        type: type
                    });
                    
                    saveCollectionToSettings(redrawAllAnnotations);
                }

                async function renderPdf(data, annotations) {
                    pdfViewer.innerHTML = '';
                    try {
                        const pdf = await pdfjsLib.getDocument({ data }).promise;
                        currentPdfDocument = pdf;
                        for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                            const page = await pdf.getPage(pageNum);
                            const viewport = page.getViewport({ scale: 1.5 });
                            const pageContainer = document.createElement('div');
                            pageContainer.className = 'page-container';
                            pageContainer.style.width = `${viewport.width}px`;
                            pageContainer.style.height = `${viewport.height}px`;
                            
                            const pdfCanvas = document.createElement('canvas');
                            pdfCanvas.width = viewport.width; pdfCanvas.height = viewport.height;
                            
                            const annotationCanvas = document.createElement('canvas');
                            annotationCanvas.className = 'annotation-canvas';
                            annotationCanvas.width = viewport.width; annotationCanvas.height = viewport.height;
                            
                            pageContainer.append(pdfCanvas, annotationCanvas);
                            pdfViewer.appendChild(pageContainer);

                            await page.render({ canvasContext: pdfCanvas.getContext('2d'), viewport: viewport }).promise;
                            drawAnnotations(pageNum, annotationCanvas, annotations);

                            annotationCanvas.addEventListener('mousedown', (e) => handleMouseDown(e, pageNum));
                            annotationCanvas.addEventListener('mousemove', (e) => handleMouseMove(e, pageNum));
                            annotationCanvas.addEventListener('mouseup', (e) => handleMouseUp(e, pageNum));
                            annotationCanvas.addEventListener('mouseleave', () => { isDrawing = false; redrawAllAnnotations(); });
                            annotationCanvas.addEventListener('click', (e) => handleClickOnCanvas(e, pageNum));
                        }
                        statusMessage.classList.add('hidden');
                    } catch (error) { updateStatus('Fout bij weergeven PDF: ' + error.message, 'error'); }
                }

                function drawAnnotations(pageNum, canvas, annotations) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    if (annotations && annotations[pageNum]) {
                        annotations[pageNum].forEach(rect => {
                           drawSingleAnnotation(ctx, rect);
                        });
                    }
                }

                function drawSingleAnnotation(ctx, rect) {
                     const isHighlighted = activeCellAddress && rect.cellAddress === activeCellAddress;
                    if (rect.type === 'approved') {
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                        ctx.strokeStyle = 'green';
                    } else if (rect.type === 'rejected') {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        ctx.strokeStyle = 'red';
                    } else { // textsnip
                        ctx.fillStyle = 'rgba(59, 130, 246, 0.3)';
                        ctx.strokeStyle = '#1d4ed8';
                    }

                    if (isHighlighted) {
                        ctx.strokeStyle = '#0078D4';
                        ctx.lineWidth = 4;
                    } else {
                        ctx.lineWidth = 2;
                    }
                    ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
                    ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
                }
                
                function redrawAllAnnotations() {
                    const pdfObject = pdfCollection.find(p => p.id === activePdfId);
                    if (!pdfObject) return;
                    const annotationCanvases = document.querySelectorAll('.annotation-canvas');
                    annotationCanvases.forEach((canvas, index) => {
                        const pageNum = index + 1;
                        drawAnnotations(pageNum, canvas, pdfObject.annotations);
                    });
                }

                // --- HELPER & UTILITY FUNCTIONS ---
                
                async function formatLinkedCell(address, type, text = "") {
                    try {
                        await Excel.run(async (context) => {
                            const range = context.workbook.worksheets.getActiveWorksheet().getRange(address);
                            if (type === 'approved') {
                                range.format.fill.color = "#D9EAD3"; range.values = [["✓"]]; range.format.font.color = "#38761D"; range.format.font.bold = true; range.format.horizontalAlignment = "Center";
                            } else if (type === 'rejected') {
                                range.format.fill.color = "#F4CCCC"; range.values = [["X"]]; range.format.font.color = "#990000"; range.format.font.bold = true; range.format.horizontalAlignment = "Center";
                            } else if (type === 'textsnip') {
                                range.format.fill.color = "#CFE2F3"; range.values = [[text]]; range.format.font.color = "#0B5394"; range.format.font.bold = false; range.format.horizontalAlignment = "Left";
                            }
                            await context.sync();
                        });
                    } catch (error) { console.error("Error formatting cell: " + error); }
                }

                async function extractTextFromArea(pageNum, canvasRect) {
                    if (!currentPdfDocument) return '';
                    try {
                        const page = await currentPdfDocument.getPage(pageNum);
                        const viewport = page.getViewport({ scale: 1.5 });
                        const textContent = await page.getTextContent();
                        
                        const normX = canvasRect.w < 0 ? canvasRect.x + canvasRect.w : canvasRect.x;
                        const normY = canvasRect.h < 0 ? canvasRect.y + canvasRect.h : canvasRect.y;
                        const normW = Math.abs(canvasRect.w);
                        const normH = Math.abs(canvasRect.h);

                        const extractedItems = textContent.items.filter(item => {
                            const itemX = item.transform[4];
                            const itemY = viewport.height - item.transform[5];
                            const itemWidth = item.width;
                            const itemHeight = item.height;

                            // Check for overlap between the drawn rectangle and the text item's bounding box
                            return (
                                itemX < normX + normW &&
                                itemX + itemWidth > normX &&
                                itemY < normY + normH &&
                                itemY + itemHeight > normY
                            );
                        });
                        
                        return extractedItems.map(item => item.str).join(' ');
                    } catch (error) {
                        console.error("Error extracting text: ", error);
                        return '[Fout bij tekstextractie]';
                    }
                }

                function handleClickOnCanvas(e, pageNum) {
                    const pdfObject = pdfCollection.find(p => p.id === activePdfId);
                    if (!pdfObject?.annotations?.[pageNum]) return;
                    
                    const rect = e.target.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const clickY = e.clientY - rect.top;
                    
                    const clickedAnnotation = [...pdfObject.annotations[pageNum]].reverse().find(anno => 
                        clickX >= anno.x && clickX <= anno.x + anno.w && 
                        clickY >= anno.y && clickY <= anno.y + anno.h
                    );
                    
                    if (clickedAnnotation) {
                        if (currentDrawMode) {
                            setDrawMode(null); 
                        }
                        navigateToCell(clickedAnnotation.cellAddress);
                    }
                }

                async function navigateToCell(fullAddress) { 
                    try { 
                        await Excel.run(async (context) => { 
                            let sheetName, rangeAddress;
                            if (fullAddress.includes('!')) {
                                const parts = fullAddress.split('!');
                                sheetName = parts[0].replace(/'/g, ''); 
                                rangeAddress = parts[1];
                            } else {
                                // Fallback to active sheet if no sheet name is specified
                                sheetName = context.workbook.worksheets.getActiveWorksheet().load('name');
                                await context.sync();
                                sheetName = sheetName.name;
                                rangeAddress = fullAddress;
                            }
                            const sheet = context.workbook.worksheets.getItem(sheetName);
                            const range = sheet.getRange(rangeAddress);
                            sheet.activate();
                            range.select();
                            await context.sync();
                        });
                    } catch (error) {
                         console.error(`Error navigating to cell ${fullAddress}:`, error);
                         updateStatus(`Kon niet navigeren naar ${fullAddress}.`, 'error');
                    }
                }

                function findAnnotationByCellAddress(address) {
                    for (const pdf of pdfCollection) {
                        if (pdf.annotations) {
                            for (const pageNum in pdf.annotations) {
                                const foundAnnotation = pdf.annotations[pageNum].find(annotation => annotation.cellAddress === address);
                                if (foundAnnotation) {
                                    return { pdfId: pdf.id, pageNum: parseInt(pageNum, 10), annotation: foundAnnotation };
                                }
                            }
                        }
                    }
                    return null;
                }

                function scrollToPage(pageNum) {
                    const pageContainers = document.querySelectorAll('.page-container');
                    const targetPage = pageContainers[pageNum - 1];
                    if (targetPage) {
                        targetPage.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }

                function showManualTextInputModal(address, rect, pageNum) {
                    manualInputState = { address, rect, pageNum };
                    manualTextInput.value = '';
                    manualTextModal.classList.remove('hidden');
                }
                function hideManualTextInputModal() {
                    manualTextModal.classList.add('hidden');
                    manualInputState = null;
                }
                async function handleManualSave() {
                    const text = manualTextInput.value;
                    if (manualInputState) {
                        await formatLinkedCell(manualInputState.address, 'textsnip', text);
                        saveAnnotation(manualInputState.pageNum, manualInputState.rect, 'textsnip');
                        hideManualTextInputModal();
                    }
                }
                function handleManualCancel() {
                    hideManualTextInputModal();
                    redrawAllAnnotations(); // Remove temporary drawing
                }

                async function switchActivePdf() {
                    const selectedId = pdfSwitcher.value;
                    if (selectedId) { await loadPdf(selectedId); }
                }

                function deleteCurrentPdf() {
                    if (!activePdfId) return;
                    pdfCollection = pdfCollection.filter(p => p.id !== activePdfId);
                    activePdfId = null;
                    saveCollectionToSettings(initializeApp);
                }

                function updatePdfSwitcher() {
                    pdfSwitcher.innerHTML = '';
                    if (pdfCollection.length === 0) {
                        pdfSwitcher.innerHTML = '<option>Geen documenten geladen</option>';
                        return;
                    }
                    pdfCollection.forEach(pdf => {
                        const option = document.createElement('option');
                        option.value = pdf.id;
                        option.textContent = pdf.name;
                        if (pdf.id === activePdfId) {
                            option.selected = true;
                        }
                        pdfSwitcher.appendChild(option);
                    });
                }
                
                function setButtonsState(enabled) {
                    const buttons = [exportButton, approveButton, rejectButton, textsnipButton, deleteButton];
                    buttons.forEach(btn => {
                        btn.disabled = !enabled;
                        btn.classList.toggle('bg-gray-300', !enabled);
                    });
                    exportButton.classList.toggle('bg-orange-500', enabled);
                    exportButton.classList.toggle('hover:bg-orange-600', enabled);
                    approveButton.classList.toggle('bg-green-600', enabled);
                    approveButton.classList.toggle('hover:bg-green-700', enabled);
                    rejectButton.classList.toggle('bg-red-600', enabled);
                    rejectButton.classList.toggle('hover:bg-red-700', enabled);
                    textsnipButton.classList.toggle('bg-blue-600', enabled);
                    textsnipButton.classList.toggle('hover:bg-blue-700', enabled);
                }

                function setDrawMode(mode) {
                    currentDrawMode = (currentDrawMode === mode) ? null : mode;
                    approveButton.classList.toggle('approve-mode-active', currentDrawMode === 'approved');
                    rejectButton.classList.toggle('reject-mode-active', currentDrawMode === 'rejected');
                    textsnipButton.classList.toggle('textsnip-mode-active', currentDrawMode === 'textsnip');
                    document.querySelectorAll('.annotation-canvas').forEach(c => c.style.cursor = currentDrawMode ? 'crosshair' : 'default');
                }

                function saveCollectionToSettings(callback) {
                    Office.context.document.settings.set('pdfCollection', JSON.stringify(pdfCollection));
                    Office.context.document.settings.saveAsync(result => {
                        if (result.status === Office.AsyncResultStatus.Failed) {
                            updateStatus('Fout bij opslaan: ' + result.error.message, 'error');
                        } else if (callback) {
                            callback();
                        }
                    });
                }

                function exportPdfFromSettings() {
                    if (!activePdfId) return;
                    const pdfObject = pdfCollection.find(p => p.id === activePdfId);
                    if (!pdfObject) return;
                    try {
                        const pdfData = base64ToUint8Array(pdfObject.data);
                        const blob = new Blob([pdfData], { type: 'application/pdf' });
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        link.download = pdfObject.name;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(link.href);
                    } catch (error) { updateStatus('Fout tijdens exporteren: ' + error.message, 'error'); }
                }
                
                function arrayBufferToBase64(buffer) { let binary = ''; const bytes = new Uint8Array(buffer); for (let i = 0; i < bytes.byteLength; i++) { binary += String.fromCharCode(bytes[i]); } return window.btoa(binary); }
                function base64ToUint8Array(base64) { const binary_string = window.atob(base64); const len = binary_string.length; const bytes = new Uint8Array(len); for (let i = 0; i < len; i++) { bytes[i] = binary_string.charCodeAt(i); } return bytes; }
                function showLoader(text) { statusMessage.classList.remove('hidden'); loader.classList.remove('hidden'); statusText.textContent = text; pdfViewer.innerHTML = ''; }
                
                // *** BIJGEWERKT: Ondersteunt nu het zichtbaar houden van de lader ***
                function updateStatus(text, type, keepLoader = false) {
                    statusMessage.classList.remove('hidden');
                    statusText.textContent = text;
                    // Reset classes voor de zekerheid
                    statusText.classList.remove('text-red-500', 'text-green-500', 'text-gray-500');

                    if (type === 'error') statusText.classList.add('text-red-500');
                    else if (type === 'success') statusText.classList.add('text-green-500');
                    else statusText.classList.add('text-gray-500');

                    if (keepLoader) {
                        loader.classList.remove('hidden');
                    } else {
                        loader.classList.add('hidden');
                    }
                }

                // --- INITIALIZE ---
                initializeApp();
            }
        });
    </script>
</body>
</html>



